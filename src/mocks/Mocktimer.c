/* AUTOGENERATED FILE. DO NOT EDIT. */
#include <string.h>
#include <stdlib.h>
#include <setjmp.h>
#include "cmock.h"
#include "Mocktimer.h"

static const char* CMockString_cb = "cb";
static const char* CMockString_data = "data";
static const char* CMockString_duty_cycle = "duty_cycle";
static const char* CMockString_freq = "freq";
static const char* CMockString_microseconds = "microseconds";
static const char* CMockString_milliseconds = "milliseconds";
static const char* CMockString_pwm_instance = "pwm_instance";
static const char* CMockString_self = "self";
static const char* CMockString_timer_delay = "timer_delay";
static const char* CMockString_timer_delay_micros = "timer_delay_micros";
static const char* CMockString_timer_get_tick = "timer_get_tick";
static const char* CMockString_timer_instance = "timer_instance";
static const char* CMockString_timer_micros = "timer_micros";
static const char* CMockString_timer_millis = "timer_millis";
static const char* CMockString_timer_set_pwm_callback = "timer_set_pwm_callback";
static const char* CMockString_timer_set_pwm_duty_cycle = "timer_set_pwm_duty_cycle";
static const char* CMockString_timer_set_pwm_freq = "timer_set_pwm_freq";
static const char* CMockString_timer_start = "timer_start";
static const char* CMockString_timer_start_microsecond_timer = "timer_start_microsecond_timer";
static const char* CMockString_timer_start_pwm = "timer_start_pwm";
static const char* CMockString_timer_stop = "timer_stop";
static const char* CMockString_timer_stop_microsecond_timer = "timer_stop_microsecond_timer";
static const char* CMockString_timer_stop_pwm = "timer_stop_pwm";

typedef struct _CMOCK_timer_start_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  Timer Expected_self;
  void* Expected_timer_instance;
  uint32_t Expected_freq;

} CMOCK_timer_start_CALL_INSTANCE;

typedef struct _CMOCK_timer_stop_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  Timer Expected_self;
  void* Expected_timer_instance;

} CMOCK_timer_stop_CALL_INSTANCE;

typedef struct _CMOCK_timer_get_tick_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  uint32_t ReturnVal;
  Timer Expected_self;
  void* Expected_timer_instance;

} CMOCK_timer_get_tick_CALL_INSTANCE;

typedef struct _CMOCK_timer_start_microsecond_timer_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  Timer Expected_self;
  void* Expected_timer_instance;

} CMOCK_timer_start_microsecond_timer_CALL_INSTANCE;

typedef struct _CMOCK_timer_stop_microsecond_timer_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  Timer Expected_self;
  void* Expected_timer_instance;

} CMOCK_timer_stop_microsecond_timer_CALL_INSTANCE;

typedef struct _CMOCK_timer_delay_micros_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  Timer Expected_self;
  uint32_t Expected_microseconds;

} CMOCK_timer_delay_micros_CALL_INSTANCE;

typedef struct _CMOCK_timer_delay_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  Timer Expected_self;
  uint32_t Expected_milliseconds;

} CMOCK_timer_delay_CALL_INSTANCE;

typedef struct _CMOCK_timer_micros_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  uint32_t ReturnVal;
  Timer Expected_self;

} CMOCK_timer_micros_CALL_INSTANCE;

typedef struct _CMOCK_timer_millis_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  uint32_t ReturnVal;
  Timer Expected_self;

} CMOCK_timer_millis_CALL_INSTANCE;

typedef struct _CMOCK_timer_start_pwm_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  Timer Expected_self;
  void* Expected_pwm_instance;
  uint32_t Expected_freq;
  uint16_t Expected_duty_cycle;

} CMOCK_timer_start_pwm_CALL_INSTANCE;

typedef struct _CMOCK_timer_stop_pwm_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  Timer Expected_self;
  void* Expected_pwm_instance;

} CMOCK_timer_stop_pwm_CALL_INSTANCE;

typedef struct _CMOCK_timer_set_pwm_freq_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  Timer Expected_self;
  void* Expected_pwm_instance;
  uint32_t Expected_freq;

} CMOCK_timer_set_pwm_freq_CALL_INSTANCE;

typedef struct _CMOCK_timer_set_pwm_duty_cycle_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  Timer Expected_self;
  void* Expected_pwm_instance;
  uint16_t Expected_duty_cycle;

} CMOCK_timer_set_pwm_duty_cycle_CALL_INSTANCE;

typedef struct _CMOCK_timer_set_pwm_callback_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  Timer Expected_self;
  PeriodicCallback Expected_cb;
  void* Expected_data;

} CMOCK_timer_set_pwm_callback_CALL_INSTANCE;

static struct MocktimerInstance
{
  CMOCK_MEM_INDEX_TYPE timer_start_CallInstance;
  CMOCK_MEM_INDEX_TYPE timer_stop_CallInstance;
  CMOCK_MEM_INDEX_TYPE timer_get_tick_CallInstance;
  CMOCK_MEM_INDEX_TYPE timer_start_microsecond_timer_CallInstance;
  CMOCK_MEM_INDEX_TYPE timer_stop_microsecond_timer_CallInstance;
  CMOCK_MEM_INDEX_TYPE timer_delay_micros_CallInstance;
  CMOCK_MEM_INDEX_TYPE timer_delay_CallInstance;
  CMOCK_MEM_INDEX_TYPE timer_micros_CallInstance;
  CMOCK_MEM_INDEX_TYPE timer_millis_CallInstance;
  CMOCK_MEM_INDEX_TYPE timer_start_pwm_CallInstance;
  CMOCK_MEM_INDEX_TYPE timer_stop_pwm_CallInstance;
  CMOCK_MEM_INDEX_TYPE timer_set_pwm_freq_CallInstance;
  CMOCK_MEM_INDEX_TYPE timer_set_pwm_duty_cycle_CallInstance;
  CMOCK_MEM_INDEX_TYPE timer_set_pwm_callback_CallInstance;
} Mock;

extern jmp_buf AbortFrame;

void Mocktimer_Verify(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_MEM_INDEX_TYPE call_instance;
  call_instance = Mock.timer_start_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_timer_start);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.timer_stop_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_timer_stop);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.timer_get_tick_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_timer_get_tick);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.timer_start_microsecond_timer_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_timer_start_microsecond_timer);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.timer_stop_microsecond_timer_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_timer_stop_microsecond_timer);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.timer_delay_micros_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_timer_delay_micros);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.timer_delay_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_timer_delay);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.timer_micros_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_timer_micros);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.timer_millis_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_timer_millis);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.timer_start_pwm_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_timer_start_pwm);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.timer_stop_pwm_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_timer_stop_pwm);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.timer_set_pwm_freq_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_timer_set_pwm_freq);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.timer_set_pwm_duty_cycle_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_timer_set_pwm_duty_cycle);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.timer_set_pwm_callback_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_timer_set_pwm_callback);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
}

void Mocktimer_Init(void)
{
  Mocktimer_Destroy();
}

void Mocktimer_Destroy(void)
{
  CMock_Guts_MemFreeAll();
  memset(&Mock, 0, sizeof(Mock));
}

void timer_start(Timer self, void* timer_instance, uint32_t freq)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_timer_start_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_timer_start);
  cmock_call_instance = (CMOCK_timer_start_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.timer_start_CallInstance);
  Mock.timer_start_CallInstance = CMock_Guts_MemNext(Mock.timer_start_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_timer_start,CMockString_self);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_self), (void*)(&self), sizeof(Timer), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_timer_start,CMockString_timer_instance);
    if (cmock_call_instance->Expected_timer_instance == NULL)
      { UNITY_TEST_ASSERT_NULL(timer_instance, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_HEX8_ARRAY(cmock_call_instance->Expected_timer_instance, timer_instance, 1, cmock_line, CMockStringMismatch); }
  }
  {
    UNITY_SET_DETAILS(CMockString_timer_start,CMockString_freq);
    UNITY_TEST_ASSERT_EQUAL_HEX32(cmock_call_instance->Expected_freq, freq, cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
}

void CMockExpectParameters_timer_start(CMOCK_timer_start_CALL_INSTANCE* cmock_call_instance, Timer self, void* timer_instance, uint32_t freq);
void CMockExpectParameters_timer_start(CMOCK_timer_start_CALL_INSTANCE* cmock_call_instance, Timer self, void* timer_instance, uint32_t freq)
{
  memcpy((void*)(&cmock_call_instance->Expected_self), (void*)(&self),
         sizeof(Timer[sizeof(self) == sizeof(Timer) ? 1 : -1])); /* add Timer to :treat_as_array if this causes an error */
  cmock_call_instance->Expected_timer_instance = timer_instance;
  cmock_call_instance->Expected_freq = freq;
}

void timer_start_CMockExpect(UNITY_LINE_TYPE cmock_line, Timer self, void* timer_instance, uint32_t freq)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_timer_start_CALL_INSTANCE));
  CMOCK_timer_start_CALL_INSTANCE* cmock_call_instance = (CMOCK_timer_start_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.timer_start_CallInstance = CMock_Guts_MemChain(Mock.timer_start_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_timer_start(cmock_call_instance, self, timer_instance, freq);
}

void timer_stop(Timer self, void* timer_instance)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_timer_stop_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_timer_stop);
  cmock_call_instance = (CMOCK_timer_stop_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.timer_stop_CallInstance);
  Mock.timer_stop_CallInstance = CMock_Guts_MemNext(Mock.timer_stop_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_timer_stop,CMockString_self);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_self), (void*)(&self), sizeof(Timer), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_timer_stop,CMockString_timer_instance);
    if (cmock_call_instance->Expected_timer_instance == NULL)
      { UNITY_TEST_ASSERT_NULL(timer_instance, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_HEX8_ARRAY(cmock_call_instance->Expected_timer_instance, timer_instance, 1, cmock_line, CMockStringMismatch); }
  }
  UNITY_CLR_DETAILS();
}

void CMockExpectParameters_timer_stop(CMOCK_timer_stop_CALL_INSTANCE* cmock_call_instance, Timer self, void* timer_instance);
void CMockExpectParameters_timer_stop(CMOCK_timer_stop_CALL_INSTANCE* cmock_call_instance, Timer self, void* timer_instance)
{
  memcpy((void*)(&cmock_call_instance->Expected_self), (void*)(&self),
         sizeof(Timer[sizeof(self) == sizeof(Timer) ? 1 : -1])); /* add Timer to :treat_as_array if this causes an error */
  cmock_call_instance->Expected_timer_instance = timer_instance;
}

void timer_stop_CMockExpect(UNITY_LINE_TYPE cmock_line, Timer self, void* timer_instance)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_timer_stop_CALL_INSTANCE));
  CMOCK_timer_stop_CALL_INSTANCE* cmock_call_instance = (CMOCK_timer_stop_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.timer_stop_CallInstance = CMock_Guts_MemChain(Mock.timer_stop_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_timer_stop(cmock_call_instance, self, timer_instance);
}

uint32_t timer_get_tick(Timer self, void* timer_instance)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_timer_get_tick_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_timer_get_tick);
  cmock_call_instance = (CMOCK_timer_get_tick_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.timer_get_tick_CallInstance);
  Mock.timer_get_tick_CallInstance = CMock_Guts_MemNext(Mock.timer_get_tick_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_timer_get_tick,CMockString_self);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_self), (void*)(&self), sizeof(Timer), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_timer_get_tick,CMockString_timer_instance);
    if (cmock_call_instance->Expected_timer_instance == NULL)
      { UNITY_TEST_ASSERT_NULL(timer_instance, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_HEX8_ARRAY(cmock_call_instance->Expected_timer_instance, timer_instance, 1, cmock_line, CMockStringMismatch); }
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_timer_get_tick(CMOCK_timer_get_tick_CALL_INSTANCE* cmock_call_instance, Timer self, void* timer_instance);
void CMockExpectParameters_timer_get_tick(CMOCK_timer_get_tick_CALL_INSTANCE* cmock_call_instance, Timer self, void* timer_instance)
{
  memcpy((void*)(&cmock_call_instance->Expected_self), (void*)(&self),
         sizeof(Timer[sizeof(self) == sizeof(Timer) ? 1 : -1])); /* add Timer to :treat_as_array if this causes an error */
  cmock_call_instance->Expected_timer_instance = timer_instance;
}

void timer_get_tick_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, Timer self, void* timer_instance, uint32_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_timer_get_tick_CALL_INSTANCE));
  CMOCK_timer_get_tick_CALL_INSTANCE* cmock_call_instance = (CMOCK_timer_get_tick_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.timer_get_tick_CallInstance = CMock_Guts_MemChain(Mock.timer_get_tick_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_timer_get_tick(cmock_call_instance, self, timer_instance);
  cmock_call_instance->ReturnVal = cmock_to_return;
}

void timer_start_microsecond_timer(Timer self, void* timer_instance)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_timer_start_microsecond_timer_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_timer_start_microsecond_timer);
  cmock_call_instance = (CMOCK_timer_start_microsecond_timer_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.timer_start_microsecond_timer_CallInstance);
  Mock.timer_start_microsecond_timer_CallInstance = CMock_Guts_MemNext(Mock.timer_start_microsecond_timer_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_timer_start_microsecond_timer,CMockString_self);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_self), (void*)(&self), sizeof(Timer), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_timer_start_microsecond_timer,CMockString_timer_instance);
    if (cmock_call_instance->Expected_timer_instance == NULL)
      { UNITY_TEST_ASSERT_NULL(timer_instance, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_HEX8_ARRAY(cmock_call_instance->Expected_timer_instance, timer_instance, 1, cmock_line, CMockStringMismatch); }
  }
  UNITY_CLR_DETAILS();
}

void CMockExpectParameters_timer_start_microsecond_timer(CMOCK_timer_start_microsecond_timer_CALL_INSTANCE* cmock_call_instance, Timer self, void* timer_instance);
void CMockExpectParameters_timer_start_microsecond_timer(CMOCK_timer_start_microsecond_timer_CALL_INSTANCE* cmock_call_instance, Timer self, void* timer_instance)
{
  memcpy((void*)(&cmock_call_instance->Expected_self), (void*)(&self),
         sizeof(Timer[sizeof(self) == sizeof(Timer) ? 1 : -1])); /* add Timer to :treat_as_array if this causes an error */
  cmock_call_instance->Expected_timer_instance = timer_instance;
}

void timer_start_microsecond_timer_CMockExpect(UNITY_LINE_TYPE cmock_line, Timer self, void* timer_instance)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_timer_start_microsecond_timer_CALL_INSTANCE));
  CMOCK_timer_start_microsecond_timer_CALL_INSTANCE* cmock_call_instance = (CMOCK_timer_start_microsecond_timer_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.timer_start_microsecond_timer_CallInstance = CMock_Guts_MemChain(Mock.timer_start_microsecond_timer_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_timer_start_microsecond_timer(cmock_call_instance, self, timer_instance);
}

void timer_stop_microsecond_timer(Timer self, void* timer_instance)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_timer_stop_microsecond_timer_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_timer_stop_microsecond_timer);
  cmock_call_instance = (CMOCK_timer_stop_microsecond_timer_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.timer_stop_microsecond_timer_CallInstance);
  Mock.timer_stop_microsecond_timer_CallInstance = CMock_Guts_MemNext(Mock.timer_stop_microsecond_timer_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_timer_stop_microsecond_timer,CMockString_self);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_self), (void*)(&self), sizeof(Timer), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_timer_stop_microsecond_timer,CMockString_timer_instance);
    if (cmock_call_instance->Expected_timer_instance == NULL)
      { UNITY_TEST_ASSERT_NULL(timer_instance, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_HEX8_ARRAY(cmock_call_instance->Expected_timer_instance, timer_instance, 1, cmock_line, CMockStringMismatch); }
  }
  UNITY_CLR_DETAILS();
}

void CMockExpectParameters_timer_stop_microsecond_timer(CMOCK_timer_stop_microsecond_timer_CALL_INSTANCE* cmock_call_instance, Timer self, void* timer_instance);
void CMockExpectParameters_timer_stop_microsecond_timer(CMOCK_timer_stop_microsecond_timer_CALL_INSTANCE* cmock_call_instance, Timer self, void* timer_instance)
{
  memcpy((void*)(&cmock_call_instance->Expected_self), (void*)(&self),
         sizeof(Timer[sizeof(self) == sizeof(Timer) ? 1 : -1])); /* add Timer to :treat_as_array if this causes an error */
  cmock_call_instance->Expected_timer_instance = timer_instance;
}

void timer_stop_microsecond_timer_CMockExpect(UNITY_LINE_TYPE cmock_line, Timer self, void* timer_instance)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_timer_stop_microsecond_timer_CALL_INSTANCE));
  CMOCK_timer_stop_microsecond_timer_CALL_INSTANCE* cmock_call_instance = (CMOCK_timer_stop_microsecond_timer_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.timer_stop_microsecond_timer_CallInstance = CMock_Guts_MemChain(Mock.timer_stop_microsecond_timer_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_timer_stop_microsecond_timer(cmock_call_instance, self, timer_instance);
}

void timer_delay_micros(Timer self, uint32_t microseconds)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_timer_delay_micros_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_timer_delay_micros);
  cmock_call_instance = (CMOCK_timer_delay_micros_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.timer_delay_micros_CallInstance);
  Mock.timer_delay_micros_CallInstance = CMock_Guts_MemNext(Mock.timer_delay_micros_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_timer_delay_micros,CMockString_self);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_self), (void*)(&self), sizeof(Timer), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_timer_delay_micros,CMockString_microseconds);
    UNITY_TEST_ASSERT_EQUAL_HEX32(cmock_call_instance->Expected_microseconds, microseconds, cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
}

void CMockExpectParameters_timer_delay_micros(CMOCK_timer_delay_micros_CALL_INSTANCE* cmock_call_instance, Timer self, uint32_t microseconds);
void CMockExpectParameters_timer_delay_micros(CMOCK_timer_delay_micros_CALL_INSTANCE* cmock_call_instance, Timer self, uint32_t microseconds)
{
  memcpy((void*)(&cmock_call_instance->Expected_self), (void*)(&self),
         sizeof(Timer[sizeof(self) == sizeof(Timer) ? 1 : -1])); /* add Timer to :treat_as_array if this causes an error */
  cmock_call_instance->Expected_microseconds = microseconds;
}

void timer_delay_micros_CMockExpect(UNITY_LINE_TYPE cmock_line, Timer self, uint32_t microseconds)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_timer_delay_micros_CALL_INSTANCE));
  CMOCK_timer_delay_micros_CALL_INSTANCE* cmock_call_instance = (CMOCK_timer_delay_micros_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.timer_delay_micros_CallInstance = CMock_Guts_MemChain(Mock.timer_delay_micros_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_timer_delay_micros(cmock_call_instance, self, microseconds);
}

void timer_delay(Timer self, uint32_t milliseconds)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_timer_delay_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_timer_delay);
  cmock_call_instance = (CMOCK_timer_delay_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.timer_delay_CallInstance);
  Mock.timer_delay_CallInstance = CMock_Guts_MemNext(Mock.timer_delay_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_timer_delay,CMockString_self);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_self), (void*)(&self), sizeof(Timer), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_timer_delay,CMockString_milliseconds);
    UNITY_TEST_ASSERT_EQUAL_HEX32(cmock_call_instance->Expected_milliseconds, milliseconds, cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
}

void CMockExpectParameters_timer_delay(CMOCK_timer_delay_CALL_INSTANCE* cmock_call_instance, Timer self, uint32_t milliseconds);
void CMockExpectParameters_timer_delay(CMOCK_timer_delay_CALL_INSTANCE* cmock_call_instance, Timer self, uint32_t milliseconds)
{
  memcpy((void*)(&cmock_call_instance->Expected_self), (void*)(&self),
         sizeof(Timer[sizeof(self) == sizeof(Timer) ? 1 : -1])); /* add Timer to :treat_as_array if this causes an error */
  cmock_call_instance->Expected_milliseconds = milliseconds;
}

void timer_delay_CMockExpect(UNITY_LINE_TYPE cmock_line, Timer self, uint32_t milliseconds)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_timer_delay_CALL_INSTANCE));
  CMOCK_timer_delay_CALL_INSTANCE* cmock_call_instance = (CMOCK_timer_delay_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.timer_delay_CallInstance = CMock_Guts_MemChain(Mock.timer_delay_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_timer_delay(cmock_call_instance, self, milliseconds);
}

uint32_t timer_micros(Timer self)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_timer_micros_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_timer_micros);
  cmock_call_instance = (CMOCK_timer_micros_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.timer_micros_CallInstance);
  Mock.timer_micros_CallInstance = CMock_Guts_MemNext(Mock.timer_micros_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_timer_micros,CMockString_self);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_self), (void*)(&self), sizeof(Timer), cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_timer_micros(CMOCK_timer_micros_CALL_INSTANCE* cmock_call_instance, Timer self);
void CMockExpectParameters_timer_micros(CMOCK_timer_micros_CALL_INSTANCE* cmock_call_instance, Timer self)
{
  memcpy((void*)(&cmock_call_instance->Expected_self), (void*)(&self),
         sizeof(Timer[sizeof(self) == sizeof(Timer) ? 1 : -1])); /* add Timer to :treat_as_array if this causes an error */
}

void timer_micros_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, Timer self, uint32_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_timer_micros_CALL_INSTANCE));
  CMOCK_timer_micros_CALL_INSTANCE* cmock_call_instance = (CMOCK_timer_micros_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.timer_micros_CallInstance = CMock_Guts_MemChain(Mock.timer_micros_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_timer_micros(cmock_call_instance, self);
  cmock_call_instance->ReturnVal = cmock_to_return;
}

uint32_t timer_millis(Timer self)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_timer_millis_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_timer_millis);
  cmock_call_instance = (CMOCK_timer_millis_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.timer_millis_CallInstance);
  Mock.timer_millis_CallInstance = CMock_Guts_MemNext(Mock.timer_millis_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_timer_millis,CMockString_self);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_self), (void*)(&self), sizeof(Timer), cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_timer_millis(CMOCK_timer_millis_CALL_INSTANCE* cmock_call_instance, Timer self);
void CMockExpectParameters_timer_millis(CMOCK_timer_millis_CALL_INSTANCE* cmock_call_instance, Timer self)
{
  memcpy((void*)(&cmock_call_instance->Expected_self), (void*)(&self),
         sizeof(Timer[sizeof(self) == sizeof(Timer) ? 1 : -1])); /* add Timer to :treat_as_array if this causes an error */
}

void timer_millis_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, Timer self, uint32_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_timer_millis_CALL_INSTANCE));
  CMOCK_timer_millis_CALL_INSTANCE* cmock_call_instance = (CMOCK_timer_millis_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.timer_millis_CallInstance = CMock_Guts_MemChain(Mock.timer_millis_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_timer_millis(cmock_call_instance, self);
  cmock_call_instance->ReturnVal = cmock_to_return;
}

void timer_start_pwm(Timer self, void* pwm_instance, uint32_t freq, uint16_t duty_cycle)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_timer_start_pwm_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_timer_start_pwm);
  cmock_call_instance = (CMOCK_timer_start_pwm_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.timer_start_pwm_CallInstance);
  Mock.timer_start_pwm_CallInstance = CMock_Guts_MemNext(Mock.timer_start_pwm_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_timer_start_pwm,CMockString_self);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_self), (void*)(&self), sizeof(Timer), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_timer_start_pwm,CMockString_pwm_instance);
    if (cmock_call_instance->Expected_pwm_instance == NULL)
      { UNITY_TEST_ASSERT_NULL(pwm_instance, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_HEX8_ARRAY(cmock_call_instance->Expected_pwm_instance, pwm_instance, 1, cmock_line, CMockStringMismatch); }
  }
  {
    UNITY_SET_DETAILS(CMockString_timer_start_pwm,CMockString_freq);
    UNITY_TEST_ASSERT_EQUAL_HEX32(cmock_call_instance->Expected_freq, freq, cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_timer_start_pwm,CMockString_duty_cycle);
    UNITY_TEST_ASSERT_EQUAL_HEX16(cmock_call_instance->Expected_duty_cycle, duty_cycle, cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
}

void CMockExpectParameters_timer_start_pwm(CMOCK_timer_start_pwm_CALL_INSTANCE* cmock_call_instance, Timer self, void* pwm_instance, uint32_t freq, uint16_t duty_cycle);
void CMockExpectParameters_timer_start_pwm(CMOCK_timer_start_pwm_CALL_INSTANCE* cmock_call_instance, Timer self, void* pwm_instance, uint32_t freq, uint16_t duty_cycle)
{
  memcpy((void*)(&cmock_call_instance->Expected_self), (void*)(&self),
         sizeof(Timer[sizeof(self) == sizeof(Timer) ? 1 : -1])); /* add Timer to :treat_as_array if this causes an error */
  cmock_call_instance->Expected_pwm_instance = pwm_instance;
  cmock_call_instance->Expected_freq = freq;
  cmock_call_instance->Expected_duty_cycle = duty_cycle;
}

void timer_start_pwm_CMockExpect(UNITY_LINE_TYPE cmock_line, Timer self, void* pwm_instance, uint32_t freq, uint16_t duty_cycle)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_timer_start_pwm_CALL_INSTANCE));
  CMOCK_timer_start_pwm_CALL_INSTANCE* cmock_call_instance = (CMOCK_timer_start_pwm_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.timer_start_pwm_CallInstance = CMock_Guts_MemChain(Mock.timer_start_pwm_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_timer_start_pwm(cmock_call_instance, self, pwm_instance, freq, duty_cycle);
}

void timer_stop_pwm(Timer self, void* pwm_instance)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_timer_stop_pwm_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_timer_stop_pwm);
  cmock_call_instance = (CMOCK_timer_stop_pwm_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.timer_stop_pwm_CallInstance);
  Mock.timer_stop_pwm_CallInstance = CMock_Guts_MemNext(Mock.timer_stop_pwm_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_timer_stop_pwm,CMockString_self);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_self), (void*)(&self), sizeof(Timer), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_timer_stop_pwm,CMockString_pwm_instance);
    if (cmock_call_instance->Expected_pwm_instance == NULL)
      { UNITY_TEST_ASSERT_NULL(pwm_instance, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_HEX8_ARRAY(cmock_call_instance->Expected_pwm_instance, pwm_instance, 1, cmock_line, CMockStringMismatch); }
  }
  UNITY_CLR_DETAILS();
}

void CMockExpectParameters_timer_stop_pwm(CMOCK_timer_stop_pwm_CALL_INSTANCE* cmock_call_instance, Timer self, void* pwm_instance);
void CMockExpectParameters_timer_stop_pwm(CMOCK_timer_stop_pwm_CALL_INSTANCE* cmock_call_instance, Timer self, void* pwm_instance)
{
  memcpy((void*)(&cmock_call_instance->Expected_self), (void*)(&self),
         sizeof(Timer[sizeof(self) == sizeof(Timer) ? 1 : -1])); /* add Timer to :treat_as_array if this causes an error */
  cmock_call_instance->Expected_pwm_instance = pwm_instance;
}

void timer_stop_pwm_CMockExpect(UNITY_LINE_TYPE cmock_line, Timer self, void* pwm_instance)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_timer_stop_pwm_CALL_INSTANCE));
  CMOCK_timer_stop_pwm_CALL_INSTANCE* cmock_call_instance = (CMOCK_timer_stop_pwm_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.timer_stop_pwm_CallInstance = CMock_Guts_MemChain(Mock.timer_stop_pwm_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_timer_stop_pwm(cmock_call_instance, self, pwm_instance);
}

void timer_set_pwm_freq(Timer self, void* pwm_instance, uint32_t freq)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_timer_set_pwm_freq_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_timer_set_pwm_freq);
  cmock_call_instance = (CMOCK_timer_set_pwm_freq_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.timer_set_pwm_freq_CallInstance);
  Mock.timer_set_pwm_freq_CallInstance = CMock_Guts_MemNext(Mock.timer_set_pwm_freq_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_timer_set_pwm_freq,CMockString_self);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_self), (void*)(&self), sizeof(Timer), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_timer_set_pwm_freq,CMockString_pwm_instance);
    if (cmock_call_instance->Expected_pwm_instance == NULL)
      { UNITY_TEST_ASSERT_NULL(pwm_instance, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_HEX8_ARRAY(cmock_call_instance->Expected_pwm_instance, pwm_instance, 1, cmock_line, CMockStringMismatch); }
  }
  {
    UNITY_SET_DETAILS(CMockString_timer_set_pwm_freq,CMockString_freq);
    UNITY_TEST_ASSERT_EQUAL_HEX32(cmock_call_instance->Expected_freq, freq, cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
}

void CMockExpectParameters_timer_set_pwm_freq(CMOCK_timer_set_pwm_freq_CALL_INSTANCE* cmock_call_instance, Timer self, void* pwm_instance, uint32_t freq);
void CMockExpectParameters_timer_set_pwm_freq(CMOCK_timer_set_pwm_freq_CALL_INSTANCE* cmock_call_instance, Timer self, void* pwm_instance, uint32_t freq)
{
  memcpy((void*)(&cmock_call_instance->Expected_self), (void*)(&self),
         sizeof(Timer[sizeof(self) == sizeof(Timer) ? 1 : -1])); /* add Timer to :treat_as_array if this causes an error */
  cmock_call_instance->Expected_pwm_instance = pwm_instance;
  cmock_call_instance->Expected_freq = freq;
}

void timer_set_pwm_freq_CMockExpect(UNITY_LINE_TYPE cmock_line, Timer self, void* pwm_instance, uint32_t freq)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_timer_set_pwm_freq_CALL_INSTANCE));
  CMOCK_timer_set_pwm_freq_CALL_INSTANCE* cmock_call_instance = (CMOCK_timer_set_pwm_freq_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.timer_set_pwm_freq_CallInstance = CMock_Guts_MemChain(Mock.timer_set_pwm_freq_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_timer_set_pwm_freq(cmock_call_instance, self, pwm_instance, freq);
}

void timer_set_pwm_duty_cycle(Timer self, void* pwm_instance, uint16_t duty_cycle)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_timer_set_pwm_duty_cycle_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_timer_set_pwm_duty_cycle);
  cmock_call_instance = (CMOCK_timer_set_pwm_duty_cycle_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.timer_set_pwm_duty_cycle_CallInstance);
  Mock.timer_set_pwm_duty_cycle_CallInstance = CMock_Guts_MemNext(Mock.timer_set_pwm_duty_cycle_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_timer_set_pwm_duty_cycle,CMockString_self);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_self), (void*)(&self), sizeof(Timer), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_timer_set_pwm_duty_cycle,CMockString_pwm_instance);
    if (cmock_call_instance->Expected_pwm_instance == NULL)
      { UNITY_TEST_ASSERT_NULL(pwm_instance, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_HEX8_ARRAY(cmock_call_instance->Expected_pwm_instance, pwm_instance, 1, cmock_line, CMockStringMismatch); }
  }
  {
    UNITY_SET_DETAILS(CMockString_timer_set_pwm_duty_cycle,CMockString_duty_cycle);
    UNITY_TEST_ASSERT_EQUAL_HEX16(cmock_call_instance->Expected_duty_cycle, duty_cycle, cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
}

void CMockExpectParameters_timer_set_pwm_duty_cycle(CMOCK_timer_set_pwm_duty_cycle_CALL_INSTANCE* cmock_call_instance, Timer self, void* pwm_instance, uint16_t duty_cycle);
void CMockExpectParameters_timer_set_pwm_duty_cycle(CMOCK_timer_set_pwm_duty_cycle_CALL_INSTANCE* cmock_call_instance, Timer self, void* pwm_instance, uint16_t duty_cycle)
{
  memcpy((void*)(&cmock_call_instance->Expected_self), (void*)(&self),
         sizeof(Timer[sizeof(self) == sizeof(Timer) ? 1 : -1])); /* add Timer to :treat_as_array if this causes an error */
  cmock_call_instance->Expected_pwm_instance = pwm_instance;
  cmock_call_instance->Expected_duty_cycle = duty_cycle;
}

void timer_set_pwm_duty_cycle_CMockExpect(UNITY_LINE_TYPE cmock_line, Timer self, void* pwm_instance, uint16_t duty_cycle)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_timer_set_pwm_duty_cycle_CALL_INSTANCE));
  CMOCK_timer_set_pwm_duty_cycle_CALL_INSTANCE* cmock_call_instance = (CMOCK_timer_set_pwm_duty_cycle_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.timer_set_pwm_duty_cycle_CallInstance = CMock_Guts_MemChain(Mock.timer_set_pwm_duty_cycle_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_timer_set_pwm_duty_cycle(cmock_call_instance, self, pwm_instance, duty_cycle);
}

void timer_set_pwm_callback(Timer self, PeriodicCallback cb, void* data)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_timer_set_pwm_callback_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_timer_set_pwm_callback);
  cmock_call_instance = (CMOCK_timer_set_pwm_callback_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.timer_set_pwm_callback_CallInstance);
  Mock.timer_set_pwm_callback_CallInstance = CMock_Guts_MemNext(Mock.timer_set_pwm_callback_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_timer_set_pwm_callback,CMockString_self);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_self), (void*)(&self), sizeof(Timer), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_timer_set_pwm_callback,CMockString_cb);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_cb), (void*)(&cb), sizeof(PeriodicCallback), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_timer_set_pwm_callback,CMockString_data);
    if (cmock_call_instance->Expected_data == NULL)
      { UNITY_TEST_ASSERT_NULL(data, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_HEX8_ARRAY(cmock_call_instance->Expected_data, data, 1, cmock_line, CMockStringMismatch); }
  }
  UNITY_CLR_DETAILS();
}

void CMockExpectParameters_timer_set_pwm_callback(CMOCK_timer_set_pwm_callback_CALL_INSTANCE* cmock_call_instance, Timer self, PeriodicCallback cb, void* data);
void CMockExpectParameters_timer_set_pwm_callback(CMOCK_timer_set_pwm_callback_CALL_INSTANCE* cmock_call_instance, Timer self, PeriodicCallback cb, void* data)
{
  memcpy((void*)(&cmock_call_instance->Expected_self), (void*)(&self),
         sizeof(Timer[sizeof(self) == sizeof(Timer) ? 1 : -1])); /* add Timer to :treat_as_array if this causes an error */
  memcpy((void*)(&cmock_call_instance->Expected_cb), (void*)(&cb),
         sizeof(PeriodicCallback[sizeof(cb) == sizeof(PeriodicCallback) ? 1 : -1])); /* add PeriodicCallback to :treat_as_array if this causes an error */
  cmock_call_instance->Expected_data = data;
}

void timer_set_pwm_callback_CMockExpect(UNITY_LINE_TYPE cmock_line, Timer self, PeriodicCallback cb, void* data)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_timer_set_pwm_callback_CALL_INSTANCE));
  CMOCK_timer_set_pwm_callback_CALL_INSTANCE* cmock_call_instance = (CMOCK_timer_set_pwm_callback_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.timer_set_pwm_callback_CallInstance = CMock_Guts_MemChain(Mock.timer_set_pwm_callback_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_timer_set_pwm_callback(cmock_call_instance, self, cb, data);
}

